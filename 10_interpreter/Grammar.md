# Состав проекта и зависимости


# Грамматика

Недостаток теории не позволил сделать всё грамотно. 
Грамматика получилась с рекурсиями, алгоритмы используются неэффективные. 
Но я рад уже тому, что получилось хотя бы расширяемое решение, в которое можно легко добавлять новые правила. 

Грамматика для арифметических выражений:  
1) Expression -> Term + Expression | Term - Expression  
2) Expression -> Term  
3) Term -> Term * Factor | Term / Factor  
4) Term -> Factor  
5) Factor -> id  
6) Factor -> const  
7) Factor -> ( Expression )  

Грамматика для операций присваивания:  
1) Start -> Statement ; Start  
2) Start -> Empty  
3) Statement -> id = Expression  

Грамматика для операций сравнения:  
1) Expression -> Expression == Expression | Expression != Expression | Expression < Expression |
      Expression > Expression | Expression <= Expression | Expression >= Expression  

Грамматика для логических операций:  
1) Expression -> Term && Expression | Term || Expression | Term ^ Expression  
2) Term -> !Term

Грамматика для вызова функций от одного аргумента:
1) Factor -> id(Expression) 

Грамматика для работы с массивами:
1) List -> Expression | List, Expression  
2) Statement -> id = \[List\]  
3) Factor -> id\[Expression\]   
4) Statement -> id\[Expression\] = Expression  

# Как это работает?  
## Лексический анализ  
### Идеи
Есть несколько категорий символов в алфавите:  
* буквы  
* цифры  
* пунктуация, кроме скобок  
* скобки  
* пробельные символы  

Границы лексем проходят там, где один тип символов сменяется другим.  

Соседние лексемы обязательно состоят из символов, которые входят в непересекающиеся наборы. 
Например, числовая константа может состоять из цифр и знаков препинания, 
а любые граничащие с ней лексемы, согласно правилам языка, не могут включать эти символы. 
В частности, числовая константа может граничить с арифметическими операторами, скобками, 
операторами сравнения и присваивания, а все они состоят из символов пунктуации.  

Таким образом, за один проход по коду слева направо легко выделить в коде все лексемы.  

Если считанная лексема не является идентификатором или константой, значит она должна 
входить в грамматику языка. Так можно сразу находить некоторые ошибки в коде.  

### Реализация  
При анализе кода используются следующие правила:  
* Пробельные символы игнорируются.  
* Лексемы, содержащие скобки, состоят из одного символа.  
* Если лексема ничнается с цифры, то это числовая константа. 
Она может состоять из цифр и знаков препинания. 
Если она содержит знак препинания, то это число с плавающей точкой, иначе - целое число.  
* Если лексема состоит из символов пунктуации, кроме скобок, то это оператор. 
Он должен быть известной последовательностью символов.  
* Если лексема ничнается с буквы, то это идентификатор. 
Он может состоять из букв и цифр.  

Лексема может не содержать значения и просто быть разделителем как символ ';', 
а может содержать какое-либо значение (числовое или булево) или действие (функция). 

## Синтаксический анализ  
### Идеи
Входной поток лексем анализируется с помощью LR(1)-анализа (
L - сканирование входного потока слева направо, 
R - построение правого порождения в обратном порядке, 
1 - количество предпросматриваемых символов входного потока
).  
После каждого считанного символа входного потока принимается решение: 
считать ещё один символ или произвести свёртку последних прочитанных символов.  
Одна свёртка соответствует одному правилу грамматики языка и преобразует последовательность из 
одной или более лексем в одну лексему, производя при этом дополнительные опреации (например, арифметические).  

Если считывание следующего символа приведёт к смене состояния LR-автомата, 
то необходимо считать следующие символ, иначе необходимо произвести свёртку. 
В свёртке всегда участвуют только последние из считанных символов.  

### Реализация
Как принимается решение считать символ или произвести свёртку? 
Описывать точно весь граф состояний и переходов LR-автомата показалось слишком громоздко. 
Поэтому реализован упрощённый вариант:
* Известно, что после некоторых лексем можно брать следующую из входного потока, не глядя.  
Например, арифметические операторы требуют после себя второго операнда.  
* Известно, что если встречается пара лексем во входном потоке, то их обязательно нужно прочитать вместе. 
Например, если встречается идентификатор и левая квадратная скобка, то это обращение к элементу массива, их нужно обработать вместе.  
* Первые два пункта разрешают большую часть ситуаций, когда нужно считать следующий символ. 
Но они не дают точного описания состояний и переходов автомата, поэтому остальные ситуации разрешаются полным перебором возможных свёрток. 
Подразумевается, что читаем следующий символ мы чаще, чем производим свёртку, 
а для чтения следующего символа чаще ограничиваемся первыми двумя правилами, 
а потому быстродействие страдает не очень сильно.

# Как этим пользоваться?

## Какие стандартные функции и константы есть в языке?
Добавлены следующие константы:  
* PI = 3.1415926  
* PHI = 1.618  
* true  
* false  

Добавлены следующие функции:  
* sqrt(float_number) - вычисление квадратного корня  
* square(number) - вычисление квадрата (второй степени) числа  
* print(id) - напечатать значение переменной  
* len(array_id) - узнать длину массива

## Какие правила важно соблюдать?
Не забывайте символ ';' в конце строки.  

## Пример
Простые арифметические операции:  
```
a = 1 + 2;
	a = 3
b = 2 + 3;
	b = 5
c = a + b;
	c = 8
```
Приоритет операций:  
```
a = 2 * 2 + 3;
	a = 7
b = 3 + 2 * 2;
	b = 7
c = a + b * 3;
	c = 28
```
Скобки:  
```
a = 2 * (2 + 3);
	a = 10
b = (2 + 3) * 2;
	b = 10
```
Логический тип и логические операции:  
```
x = true;
	x = true
y = false;
	y = false
z = x && y;
	z = false
z = x || y;
	z = true
z = !x;
	z = false
```
Операции сравнения:  
```
x = 1 < 2;
	x = true
y = 2 == 1;
	y = false
z = 2 != 1;
	z = true
```
Вызов функций:  
```
a = square(3);
	a = 9
b = sqrt(6.25);
	b = 2.5
```
Работа с массивами:  
```
m = [1, 2, 3, 4];
	m = array[ 1 2 3 4 ]
a = len(m);
	a = 4
print(m[1]);
	m[1] = 2
b = m[2] * 3;
	b = 9
m = [1, 2, 3, 4];
	m = array[ 1 2 3 4 ]
a = len(m);
	a = 4
print(m[1]);
	m[1] = 2
b = m[2] * 3;
	b = 9
c = square(m[3]) + 1;
	c = 17
m[0] = 5;
	m = array[ 5 2 3 4 ]
```

# ToDo
* Разобраться с эффективными алгоритмами работы с  КС-свободными грамматиками.  
* Придумать что-то с константами false_lexeme и true_lexeme, чтобы компилятор не ругался.
* Минимизировать использование const_cast<>().  
* Добавить дополнительных проверок и сообщений об ошибках, 
чтобы сообщать о большем количестве ошибочных ситуаций как можно раньше.  
* Минимизировать дублирование кода:
    * Создать шаблонные функции для выполнения одинаковых действий с разными типами данных.  
    * Добавить возможность применять одну и ту же свёртку к разным последовательностям лексем, 
    не создавая несколько похожих друг на друга свёрток.  
    * Объединить методы print и debug_print.
