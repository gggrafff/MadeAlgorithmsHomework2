/*
 * A. Кузнечик собирает монеты
 * ограничение по времени на тест 2 секунды
 * ограничение по памяти на тест 256 мегабайт
 * ввод input.txt
 * вывод output.txt
 *
 * Кузнечик прыгает по столбикам, расположенным на одной линии на равных расстояниях друг от друга.
 * Столбики имеют порядковые номера от 1 до N. В начале Кузнечик сидит на столбике с номером 1 и хочет
 * добраться до столбика с номером N. Он может прыгнуть вперед на расстояние от 1 до K столбиков, считая от текущего.
 *
 * На каждом столбике Кузнечик может получить или потерять несколько золотых монет
 * (для каждого столбика это число известно). Определите, как нужно прыгать Кузнечику,
 * чтобы собрать наибольшее количество золотых монет. Учитывайте, что Кузнечик не может прыгать назад.
 *
 * Входные данные
 * В первой строке вводятся два натуральных числа: N и K (2 ≤ N, K ≤ 10000), разделённые пробелом.
 * Во второй строке записаны через пробел N - 2 целых числа – количество монет,
 * которое Кузнечик получает на каждом столбике, от 2-го до N - 1-го. Если это число отрицательное,
 * Кузнечик теряет монеты. Гарантируется, что все числа по модулю не превосходят 10 000.
 * Выходные данные
 * В первой строке программа должна вывести наибольшее количество монет, которое может собрать Кузнечик.
 * Во второй строке выводится число прыжков Кузнечика, а в третьей строке – номера всех столбиков,
 * которые посетил Кузнечик (через пробел в порядке возрастания).
 * Если правильных ответов несколько, выведите любой из них.
 *
 * Пример
 * Входные данные
 * 5 3
 * 2 -3 5
 * Выходные данные
 * 7
 * 3
 * 1 2 4 5
 */

 /*
  * Что храним? dp[i] - максимальное число монет на пути в точку i
  * База dp[0] = coins[0] = 0
  * Переход dp[i] = coins[i] + max(dp[i-1], ..., dp[i-K])
  * Порядок по возрастанию i
  * Ответ dp[N]
  */

#include <fstream>
#include <vector>
#include <algorithm>

/**
 * @brief Путь кузнечика. Первый элемент - вектор индексов столбиков. Второй элемент - количество монет на пути.
 */
using Path = std::pair<std::vector<size_t>, int64_t>;

/**
 * @brief Поиск наиболее прибыльного пути методом динамического программировния.
 * @param N Количество столбиков.
 * @param K Максимальная длина прыжка.
 * @param coins Вектор, хранящий количество монет на каждом столбике (м.б. отрицательным).
 * @return Наиболее прибыльный путь кузнечика.
 */
Path find_profitable_path(const size_t N, const size_t K, const std::vector<int64_t>& coins) {
    std::vector<int64_t> dp(N, 0);
    std::vector<size_t> parents(1, 0);
    for (size_t i = 1; i < N; ++i) {
        auto max_profit_point = std::max_element(next(dp.begin(), (i > K ? i - K : 0)), next(dp.begin(), i));
        dp[i] = coins[i] + *max_profit_point;
        auto distance = std::distance(dp.begin(), max_profit_point);
        parents.push_back((distance > 0 ? static_cast<size_t>(distance) : 0));
    }
    std::vector<size_t> path(1, N-1);
    auto current_index = N - 1;
    while(parents[current_index] != current_index)
    {
        path.push_back(parents[current_index]);
        current_index = parents[current_index];
    }
    std::reverse(path.begin(), path.end());
    return {path, dp[N - 1]};
}

int main(int argc, char *argv[]) {
    // Чтение входных данных
    std::ifstream fin("input.txt");
    size_t N{0};
    size_t K{0};
    fin >> N >> K;
    std::vector<int64_t> coins(N, 0);
    for (uint64_t i = 1; i < N - 1; ++i) {
        fin >> coins[i];
    }
    fin.close();

    Path path = find_profitable_path(N, K, coins);

    // Запись результата
    std::ofstream fout("output.txt");
    fout << path.second << std::endl;
    fout << path.first.size() - 1 << std::endl;  // количество прыжков на 1 меньше длины пути
    for (const auto &step: path.first) {
        fout << step + 1 << " ";  // столбики нумеруются с 1 в условии
    }
    fout.close();

    return 0;
}